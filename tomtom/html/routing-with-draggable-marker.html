<!DOCTYPE html>
<html class='use-all-space'>
    <head>
        <meta http-equiv='X-UA-Compatible' content='IE=Edge' />
        <meta charset='UTF-8'>
        <title>Maps SDK for Web - Routing with draggable marker</title>
        <meta name='viewport'
            content='width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no'/>
        <link rel='stylesheet' type='text/css' href='/cdn.web-sdk-maps/maps.css'>
        <link rel='stylesheet' type='text/css' href='../assets/ui-library/index.css'/>
        <link rel='stylesheet' type='text/css' href='/cdn.web-sdk-plugin-searchbox/SearchBox.css'/>
        <link rel='stylesheet' type='text/css' href='/cdn.web-sdk-maps/css-styles/routing.css'/>
    </head>
    <style>
            #foldable {
                padding: 34px 16px 44px;
                width: 320px;
            }
            .icon-spacing-right {
                margin-right: 12px;
                margin-top: 22px;
            }
            .tt-search-box-input {
                width: calc(100% - 25px) !important;
            }
            .map-view .tt-icon.-finish {
                height: 16px;
                width: 16px;
            }
            .icon-wrapper > .tt-form-label {
                flex: 1;
                padding-right: 26px;
            }
            .map-view .draggable-marker {
                align-items: center;
                background-color: #4a90e2;
                border: solid 3px #2faaff;
                border-radius: 50%;
                display: flex;
                height: 32px;
                justify-content: center;
                transition: width .1s, height .1s;
                width: 32px;
            }
            .map-view .icon-wrapper {
                align-items: flex-end;
                display: flex;
                min-height: 52px;
            }
            .map-view .icon-spacing {
                float: left;
                margin-right: 14px;
                margin-top: 24px;
            }
    </style>
    <body>
        <div class='map-view'>
            <div id='map' class='map'>
                <div id='foldable' class='tt-overlay-panel -left-top -medium js-foldable'>
                    <div class='icon-wrapper'>
                        <div class='tt-icon icon-spacing -start'></div>
                        <div id='startSearchBox' class='tt-form-label'></div>
                    </div>
                    <div class='icon-wrapper'>
                        <div class='tt-icon icon-spacing -finish'></div>
                        <div id='finishSearchBox' class='tt-form-label'></div>
                    </div>
                </div>
            </div>
        </div>
        <script src='/cdn.web-sdk-maps/maps-web.min.js'></script>
        <script src='/cdn.web-sdk-services/services-web.min.js'></script>
        <script data-showable type='text/javascript' src='../assets/js/mobile-or-tablet.js'></script>
        <script data-showable type='text/javascript' src='../assets/js/foldable.js'></script>
        <script data-showable type='text/javascript' src='../assets/js/info-hint.js'></script>
        <script src='/cdn.web-sdk-plugin-searchbox/SearchBox-web.js'></script>
        <script>
            var map = tt.map({
                key: '${api.key.maps}',
                container: 'map',
                style: 'tomtom://vector/1/basic-main',
                dragPan: !isMobileOrTablet()
            });
            var routeMarkers = {}, routePoints = {}, searchBoxes = {};
            var finishMarkerElement = createMarkerElement('finish');
            var startMarkerElement = createMarkerElement('start');
            var errorHint = new InfoHint('error', 'bottom-center', 5000).addTo(document.getElementById('map'));
            var loadingHint = new InfoHint('info', 'bottom-center').addTo(document.getElementById('map'));
            var searchBoxesValues = {};

            map.addControl(new tt.FullscreenControl());
            map.addControl(new tt.NavigationControl());
            new Foldable('#foldable', 'top-right');
            map.on('load', function() {
                searchBoxes.start = createSearchBox('start');
                searchBoxes.finish = createSearchBox('finish');
            });

            function addRouteMarkers(type, point) {
                var lngLat = point && point[type + 'Point'] || routePoints[type];

                if (!routeMarkers[type] && routePoints[type]) {
                    routeMarkers[type] = createMarker(type, lngLat);
                }
                if (routeMarkers[type]) {
                    routeMarkers[type].setLngLat(routePoints[type]);
                }
            }

            function centerMap(lngLat) {
                map.flyTo({
                    center: lngLat,
                    speed: 10,
                    zoom: 8
                });
            }

            function clearMap() {
                if (!map.getLayer('route')) {
                    return;
                }
                map.removeLayer('route');
                map.removeSource('route');
            }

            function createMarker(type, lngLat) {
                var markerElement = type === 'start' ? startMarkerElement : finishMarkerElement;

                return new tt.Marker({ draggable: true, element: markerElement })
                    .setLngLat(lngLat)
                    .addTo(map)
                    .on('dragend', getDraggedMarkerPosition.bind(null, type));
            }

            function createMarkerElement(type) {
                var element = document.createElement('div');
                var innerElement = document.createElement('div');

                element.className = 'draggable-marker';
                innerElement.className = 'tt-icon -white -' + type;
                element.appendChild(innerElement);
                return element;
            }

            function createSearchBox(type) {
                var searchBox = new tt.plugins.SearchBox(tt.services, {
                    showSearchButton: false,
                    searchOptions: {
                        key: '${api.key.search}'
                    },
                    placeholder: 'Search for a place...'
                });

                searchBoxesValues[type] = searchBox.getSearchBoxHTML().querySelector('input.tt-search-box-input').value;
                document.getElementById(type + 'SearchBox').appendChild(searchBox.getSearchBoxHTML());
                searchBox.on('tomtom.searchbox.resultselected', onResultSelected.bind(null, type));
                searchBox.on('tomtom.searchbox.resultscleared', onResultCleared.bind(null, type));
                searchBox.getSearchBoxHTML().addEventListener('keyup', function(event) {
                    if (searchBoxesValues[type] && !event.target.value) {
                        searchBox.fire('tomtom.searchbox.resultscleared');
                    }
                    searchBoxesValues[type] = event.target.value;
                });
                return searchBox;
            }

            function getDraggedMarkerPosition(type) {
                var lngLat = routeMarkers[type].getLngLat();

                performReverseGeocodeRequest(lngLat)
                    .then(function(response) {
                        var addresses = response.addresses[0];
                        var freeFormAddress = addresses.address.freeformAddress;

                        if (!freeFormAddress) {
                            loadingHint.hide();
                            clearMap();
                            errorHint.setMessage('Address not found, please choose a different place');
                            return;
                        }
                        searchBoxes[type]
                            .getSearchBoxHTML()
                            .querySelector('input.tt-search-box-input')
                            .value = freeFormAddress;
                        var position = {
                            lng: addresses.position.lng,
                            lat: addresses.position.lat
                        };

                        updateMapView(type, position);
                    });
            }

            function handleDrawRoute(type) {
                errorHint.hide();
                loadingHint.setMessage('Loading...');
                performCalculateRouteRequest()
                    .then(function(response) {
                        var geojson = response.toGeoJson();
                        var coordinates = geojson.features[0].geometry.coordinates;

                        clearMap();
                        map.addLayer({
                            'id': 'route',
                            'type': 'line',
                            'source': {
                                'type': 'geojson',
                                'data': geojson
                            },
                            'paint': {
                                'line-color': '#4a90e2',
                                'line-width': 6
                            }
                        });
                        var bounds = new tt.LngLatBounds();
                        var point = {
                            startPoint: coordinates[0],
                            finishPoint: coordinates.slice(-1)[0]
                        };

                        addRouteMarkers(type, point);
                        coordinates.forEach(function(point) {
                            bounds.extend(tt.LngLat.convert(point));
                        });
                        map.fitBounds(bounds, { duration: 0, padding: 150 });
                        loadingHint.hide();
                    }).catch(function() {
                        clearMap();
                        errorHint.setMessage('There was a problem calculating the route');
                        loadingHint.hide();
                    });
            }

            function onResultCleared(type) {
                routePoints[type] = null;
                if (routeMarkers[type]) {
                    routeMarkers[type].remove();
                    routeMarkers[type] = null;
                }
                if (routePoints.start || routePoints.finish) {
                    var lngLat = type === 'start' ? routePoints.finish : routePoints.start;
                    clearMap();
                    centerMap(lngLat);
                }
            }

            function onResultSelected(type, event) {
                var position = event.data.result.position;

                updateMapView(type, position);
            }

            function performCalculateRouteRequest() {
                return tt.services.calculateRoute({
                    key: '${api.key.routing}',
                    traffic: false,
                    locations: routePoints.start.join() + ':' + routePoints.finish.join()
                }).go();
            }

            function performReverseGeocodeRequest(lngLat) {
                return tt.services.reverseGeocode({
                    key: '${api.key.search}',
                    position: lngLat
                }).go();
            }

            function updateMapView(type, position) {
                routePoints[type] = [position.lng, position.lat];
                if (routePoints.start && routePoints.finish) {
                    handleDrawRoute(type);
                } else {
                    addRouteMarkers(type);
                    centerMap(routePoints[type]);
                }
            }
        </script>
    </body>
</html>
